╭──────────────────────────────────────────────────╮│  > References/Hazel의 이벤트 시스템을 분석해줘.  │╰──────────────────────────────────────────────────╯✦ References/Hazel의 이벤트 시스템을 분석하겠습니다. 먼저 관련 파일들을 찾아보겠습니다. ╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │ ✔ ReadFolder References/Hazel                                                                                                                     │ │                                                                                                                                                    │ │    Listed 15 item(s).                                                                                                                              │ ╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯✦ Hazel 디렉토리 안에 관련 코드가 있을 것으로 보입니다. 해당 디렉토리의 내용을 살펴보겠습니다. ╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │ ✔ ReadFolder References/Hazel/Hazel/src/Hazel                                                                                                     │ │                                                                                                                                                    │ │    Listed 12 item(s).                                                                                                                              │ ╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯✦ 좋아, 이벤트 관련 파일들은 References/Hazel/Hazel/src/Hazel/Events에 있는 것 같군. 이제 그 디렉토리의 파일들을 나열해 보겠다. ╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │ ✔ ReadFolder ...eferences/Hazel/Hazel/src/Hazel/Events                                                                                            │ │                                                                                                                                                    │ │    Listed 4 item(s).                                                                                                                               │ ╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯✦ 좋아, 이벤트 관련 파일을 찾았어: ApplicationEvent.h, Event.h, KeyEvent.h, MouseEvent.h. 이제 이 파일들의 내용을 읽고 이벤트 시스템을 이해할 거야. ╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │ ✔ ReadManyFiles Will attempt to read and concatenate files using patterns:                                                                        │ │    /Us…                                                                                                                                            │ │                                                                                                                                                    │ │    ### ReadManyFiles Result (Target Dir: `/Users/asdf/work/cat`)                                                                                   │ │                                                                                                                                                    │ │    Successfully read and concatenated content from **4 file(s)**.                                                                                  │ │                                                                                                                                                    │ │    **Processed Files:**                                                                                                                            │ │    - `References/Hazel/Hazel/src/Hazel/Events/ApplicationEvent.h`                                                                                  │ │    - `References/Hazel/Hazel/src/Hazel/Events/Event.h`                                                                                             │ │    - `References/Hazel/Hazel/src/Hazel/Events/KeyEvent.h`                                                                                          │ │    - `References/Hazel/Hazel/src/Hazel/Events/MouseEvent.h`                                                                                        │ ╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯✦ Hazel의 이벤트 시스템은 다음과 같이 구성되어 있습니다.  1. 기본 구조 (Event.h)   * `Event` (기본 클래스): 모든 이벤트의 추상 기본 클래스입니다.       * EventType과 EventCategory 열거형(enum)을 통해 이벤트의 종류와 카테고리를 정의합니다. (예: WindowClose, KeyPressed, EventCategoryApplication,         EventCategoryInput)       * Handled (bool): 이벤트가 처리되었는지를 나타내는 플래그입니다. 이벤트가 처리되면 이 값을 true로 설정하여 다른 곳에서 중복 처리되는 것을 방지합니다.       * EVENT_CLASS_TYPE 및 EVENT_CLASS_CATEGORY 매크로: 파생 클래스에서 이벤트 유형과 카테고리를 쉽게 설정할 수 있도록 도와주는 헬퍼 매크로입니다.   * `EventDispatcher` (이벤트 처리기):       * 이벤트가 발생했을 때, 해당 이벤트를 올바른 처리 함수로 연결해주는 역할을 합니다.       * Dispatch 템플릿 함수를 통해 이벤트의 타입을 확인하고, 타입이 일치하는 경우에만 전달된 함수를 호출합니다. 이를 통해 타입에 안전한(type-safe) 방식으로         이벤트를 처리할 수 있습니다.  2. 이벤트의 종류  ApplicationEvent.h   * `WindowResizeEvent`: 윈도우 크기가 변경될 때 발생합니다. (너비, 높이 정보 포함)   * `WindowCloseEvent`: 윈도우가 닫힐 때 발생합니다.   * `AppTickEvent`, `AppUpdateEvent`, `AppRenderEvent`: 애플리케이션의 메인 루프의 각 단계(Tick, Update, Render)에서 발생하는 이벤트입니다.  KeyEvent.h   * `KeyEvent`: 키보드 이벤트의 기본 클래스입니다. (KeyCode 정보 포함)   * `KeyPressedEvent`: 키가 눌렸을 때 발생합니다. (키 반복 여부 정보 포함)   * `KeyReleasedEvent`: 키에서 손을 뗐을 때 발생합니다.   * `KeyTypedEvent`: 문자 키가 입력되었을 때 발생합니다.  MouseEvent.h   * `MouseMovedEvent`: 마우스 커서가 움직일 때 발생합니다. (x, y 좌표 정보 포함)   * `MouseScrolledEvent`: 마우스 휠을 스크롤할 때 발생합니다. (x, y 오프셋 정보 포함)   * `MouseButtonPressedEvent`: 마우스 버튼을 눌렀을 때 발생합니다.   * `MouseButtonReleasedEvent`: 마우스 버튼에서 손을 뗐을 때 발생합니다.  시스템의 특징   * 블로킹(Blocking) 방식: 이벤트가 발생하면 즉시 디스패치되어 처리됩니다. Event.h의 주석에 따르면, 미래에는 이벤트 버퍼를 사용하여 처리하는 방식으로 개선될     수 있음을 시사합니다.   * 계층적 구조: Event라는 기본 클래스를 상속받아 KeyEvent, MouseEvent 등의 중간 계층을 두고, 다시 이를 상속받아 KeyPressedEvent, MouseButtonPressedEvent     같은 구체적인 이벤트를 정의하는 계층적 구조를 가집니다.   * 타입 안전성: EventDispatcher를 통해 컴파일 타임에 이벤트 타입을 확인하므로, 잘못된 타입의 이벤트가 처리 함수로 전달되는 것을 방지합니다.  요약하자면, Hazel의 이벤트 시스템은 상속 기반의 계층적 구조를 가지며, 디스패처를 통해 타입에 안전하게 이벤트를 처리하는 블로킹 방식의 시스템입니다.╭───────────────────────────────────────────────────────╮│  > 이제 Cryengine의 이벤트 시스템을 찾아서 분석해줘.  │╰───────────────────────────────────────────────────────╯✦ CryEngine의 이벤트 시스템을 분석하겠습니다. 먼저 CryEngine의 소스 코드나 관련 문서를 찾아보겠습니다.ℹRequest cancelled. ╭───────────────────────────────────────────────────────────────────────────────╮ │ -  GoogleSearch Searching the web for: "CryEngine event system architecture"  │ ╰───────────────────────────────────────────────────────────────────────────────╯╭───────────────────────────────────────────────────────────────────────────────────────────────────╮│  > 이제 Cryengine의 이벤트 시스템을 찾아서 분석해줘. References/CRYENGINE_Source-release에 있어.  │╰───────────────────────────────────────────────────────────────────────────────────────────────────╯✦ 알겠습니다. References/CRYENGINE_Source-release에 있는 CryEngine의 이벤트 시스템을 분석하겠습니다.  먼저 해당 디렉토리의 구조를 파악하여 관련 파일을 검색하겠습니다. ╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │ ✔ ReadFolder References/CRYENGINE_Source-release                                                                                                  │ │                                                                                                                                                    │ │    Listed 17 item(s).                                                                                                                              │ ╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯✦ 알겠습니다. 디렉토리 구조는 다음과 같습니다:   * Code: 게임 코드 또는 플러그인.   * Editor: CryEngine 에디터 소스.   * Engine: 핵심 엔진 소스 코드.   * Tools: 엔진용 도구.  핵심 이벤트 시스템은 Engine 디렉토리에 있을 가능성이 높습니다. 이제 Engine 디렉토리의 내용을 나열하여 어디를 찾아야 할지 더 잘 파악하겠습니다. ╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │ ✔ ReadFolder ...rences/CRYENGINE_Source-release/Engine                                                                                            │ │                                                                                                                                                    │ │    Listed 5 item(s).                                                                                                                               │ ╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯✦ 예상과 다르네요. Engine 디렉토리에 소스 코드가 직접 포함되어 있지 않습니다. 빌드 시스템(wscript)이 이 수준에 있는 것 같습니다. 실제 소스 코드는 하위  디렉토리에 있을 수 있습니다.  다른 접근 방식을 시도해 보겠습니다. glob을 사용하여 이벤트 시스템의 일부일 가능성이 있는 파일을 검색합니다. 이름에 "Event"가 포함된 파일을 검색하고 헤더  파일(.h)부터 시작하겠습니다. References/CRYENGINE_Source-release 디렉토리 전체를 검색합니다. ╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │ ✔ FindFiles '**/*Event*.h' within References/CRYENGINE_Source-release                                                                             │ │                                                                                                                                                    │ │    Found 73 matching file(s)                                                                                                                       │ ╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯✦ 파일이 많군요. CryEngine은 매우 모듈화되고 광범위한 이벤트 시스템을 갖추고 있으며, 엔진 구성 요소마다 다른 시스템이 있음을 알 수 있습니다.  파일 목록을 기반으로 몇 가지 잠재적인 핵심 파일이 보입니다.   * Code/CryEngine/CryCommon/CryAction/ICustomEvents.h: 사용자 지정 이벤트를 위한 인터페이스 같습니다.   * Code/CryEngine/CrySystem/SystemEventDispatcher.h: 시스템 수준 이벤트를 위한 중앙 디스패처 같습니다.   * Code/CryEngine/CryCommon/CryLobby/CryLobbyEventCallback.h: 멀티플레이어용 로비 이벤트일 가능성이 높습니다.   * Code/GameSDK/GameDll/EventDistributor.h: 게임별 이벤트 배포자입니다.   * Code/GameSDK/GameDll/UI/IUIGameEventSystem.h: UI 이벤트를 위한 인터페이스입니다.  그리고 애니메이션, 오디오, 물리 등과 같은 특정 시스템을 위한 다른 많은 이벤트 관련 파일이 있습니다.  가장 중심적이고 기본적으로 보이는 Code/CryEngine/CrySystem/SystemEventDispatcher.h와 Code/CryEngine/CryCommon/CryAction/ICustomEvents.h를 먼저  살펴보겠습니다. 이 두 파일을 먼저 읽겠습니다. ╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │ ✔ ReadManyFiles Will attempt to read and concatenate files using patterns:                                                                        │ │    /Us…                                                                                                                                            │ │                                                                                                                                                    │ │    ### ReadManyFiles Result (Target Dir: `/Users/asdf/work/cat`)                                                                                   │ │                                                                                                                                                    │ │    Successfully read and concatenated content from **2 file(s)**.                                                                                  │ │                                                                                                                                                    │ │    **Processed Files:**                                                                                                                            │ │    - `References/CRYENGINE_Source-release/Code/CryEngine/CryCommon/CryAction/ICustomEvents.h`                                                      │ │    - `References/CRYENGINE_Source-release/Code/CryEngine/CrySystem/SystemEventDispatcher.h`                                                        │ ╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯✦ 분석한 두 파일을 통해 CryEngine에는 두 가지 주요 이벤트 시스템이 있음을 알 수 있습니다.  1. 시스템 이벤트 (ISystemEventDispatcher)   * 목적: 엔진의 핵심적인 상태 변화를 처리하기 위한 저수준(low-level) 이벤트 시스템입니다. (예: 창 크기 변경, 레벨 로딩 등)   * 핵심 인터페이스: ISystemEventDispatcher 와 ISystemEventListener   * 동작 방식:       1. 이벤트를 수신하려는 객체는 ISystemEventListener 인터페이스를 구현합니다.       2. ISystemEventDispatcher::RegisterListener를 통해 리스너를 등록합니다.       3. 시스템에서 특정 이벤트가 발생하면 ISystemEventDispatcher::OnSystemEvent가 호출됩니다.       4. 디스패처는 등록된 모든 리스너에게 해당 이벤트를 전파합니다.   * 특징:       * 스레드 안전(Thread-safe): 다른 스레드에서 발생한 이벤트를 처리하기 위한 큐(m_systemEventQueue)와 락(m_listenerRegistrationLock)을 갖추고 있어,         멀티스레드 환경에서 안전하게 동작합니다.       * 중앙 집중형: 엔진의 핵심 이벤트를 단일 디스패처가 관리합니다.       * 정의된 이벤트: 이벤트의 종류가 ESystemEvent 열거형(enum)으로 미리 정의되어 있습니다.  2. 커스텀 이벤트 (ICustomEventManager)   * 목적: 게임플레이 로직이나 스크립트(FlowGraph)와 같이, 사용자 정의가 필요한 고수준(high-level) 이벤트를 처리하기 위한 시스템입니다.   * 핵심 인터페이스: ICustomEventManager 와 ICustomEventListener   * 동작 방식:       1. ICustomEventManager::GetNextCustomEventId를 통해 고유한 이벤트 ID를 얻습니다.       2. 이벤트를 수신하려는 객체는 ICustomEventListener 인터페이스를 구현하고, ICustomEventManager::RegisterEventListener를 통해 특정 이벤트 ID에 대해          리스너를 등록합니다.       3. ICustomEventManager::FireEvent를 호출하여 특정 ID의 이벤트를 발생시키면, 해당 ID에 등록된 모든 리스너에게 이벤트가 전달됩니다.   * 특징:       * 유연성 및 확장성: uint32 타입의 ID를 사용하여 이벤트를 동적으로 생성하고 사용할 수 있습니다.       * 데이터 전달: TFlowInputData 타입을 통해 이벤트에 사용자 정의 데이터를 함께 실어 보낼 수 있습니다. 이는 CryEngine의 비주얼 스크립팅 시스템인         FlowGraph와의 긴밀한 통합을 시사합니다.       * 타겟팅된 전달: 리스너가 특정 이벤트 ID에 대해서만 등록하므로, 시스템 이벤트처럼 모든 이벤트를 수신하는 것이 아니라 필요한 이벤트만 선택적으로 받을 수         있습니다.  아키텍처 요약 및 비교  CryEngine의 이벤트 시스템은 계층적이며 모듈화된 구조를 가지고 있습니다.  ┌─────────────┬───────────────────────────────────────────┬────────────────────────────────────────────┐  │ 특징        │ 시스템 이벤트 (ISystemEventDispatcher)    │ 커스텀 이벤트 (ICustomEventManager)        │  ├─────────────┼───────────────────────────────────────────┼────────────────────────────────────────────┤  │ 목적        │ 엔진 코어, 저수준 상태 변화               │ 게임플레이, 고수준 로직, 스크립트          │  │ 패턴        │ 옵저버 패턴 (Observer Pattern)            │ 발행-구독 패턴 (Publish-Subscribe Pattern) │  │ 이벤트 ID   │ ESystemEvent (열거형)                     │ TCustomEventId (uint32, 동적 생성)         │  │ 데이터      │ wparam, lparam (정수형)                   │ TFlowInputData (복합 데이터 구조)          │  │ 결합도      │ 비교적 높음 (리스너가 모든 이벤트를 받음) │ 낮음 (리스너가 특정 이벤트만 구독)         │  │ 주요 사용처 │ 엔진 내부 시스템 간의 통신                │ FlowGraph, 게임 로직, UI 등                │  └─────────────┴───────────────────────────────────────────┴────────────────────────────────────────────┘  앞서 glob으로 검색했을 때 FlashUIEventSystem, PhysicsEventListener 등 다양한 이벤트 관련 파일이 발견된 것으로 보아, CryEngine은 이 두 가지 핵심 시스템  외에도 각 모듈(UI, 물리, 오디오 등)에 특화된 자체 이벤트 시스템을 두어 관심사를 분리(Separation of Concerns)하는 설계를 따르고 있습니다. 이는 거대한 단일  이벤트 관리자로 인한 복잡성을 피하고 각 모듈의 독립성을 높이는 좋은 설계 방식입니다.╭──────────────────────────────────────────────────────────────╮│  > 이제 References/UnrealEngine의 이벤트 시스템을 파악해줘.  │╰──────────────────────────────────────────────────────────────╯✦ 알겠습니다. References/UnrealEngine에 있는 언리얼 엔진의 이벤트 시스템을 분석하겠습니다. 언리얼 엔진은 매우 방대하므로, 핵심 시스템 위주로 체계적으로  접근하겠습니다.  먼저 최상위 디렉토리 구조를 파악하여 시작하겠습니다. ╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │ ✔ ReadFolder References/UnrealEngine                                                                                                              │ │                                                                                                                                                    │ │    Listed 17 item(s).                                                                                                                              │ ╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯✦ 예상대로 메인 디렉토리는 Engine입니다. 소스 코드는 Engine/Source에 있을 것입니다. 이제 Engine/Source 내에서 "Delegate" 및 "Event"에 대한 glob 검색을  수행하여 관련 파일을 찾겠습니다. 전체적인 구조를 파악하기 위해 광범위한 검색부터 시작하겠습니다. ╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │ ✔ FindFiles '**/*Delegate*.h' within ...References/UnrealEngine/Engine/Source                                                                     │ │                                                                                                                                                    │ │    Found 286 matching file(s)                                                                                                                      │ ╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯✦ 예상대로 Delegate를 검색하니 엄청난 수의 파일이 나왔습니다. 이는 델리게이트가 언리얼 엔진에서 근본적이고 널리 퍼져 있는 개념임을 확인시켜 줍니다.  가장 중요한 파일은 Runtime/Core/Public/Delegates/에 있는 것으로 보입니다. 여기가 델리게이트 시스템의 핵심입니다.   * Delegate.h: 전체 델리게이트 시스템의 메인 헤더 파일일 가능성이 높습니다.   * DelegateBase.h: 모든 델리게이트의 기본 클래스입니다.   * MulticastDelegateBase.h: 멀티캐스트 델리게이트의 기본 클래스입니다.   * DelegateInstancesImpl.h: 구현 세부 정보입니다.   * Runtime/Core/Public/Misc/의 CoreDelegates.h: 이 파일은 다른 시스템이 바인딩할 수 있는 핵심 엔진 전체 델리게이트 세트를 정의할 것입니다.  이제 핵심 메커니즘을 이해하기 위해 이 핵심 파일의 내용을 읽겠습니다. 공개 API 및 사용법을 가장 잘 나타내는 것으로 보이는 Delegate.h 및 CoreDelegates.h에  중점을 두겠습니다. ╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │ ✔ ReadManyFiles Will attempt to read and concatenate files using patterns:                                                                        │ │    /Us…                                                                                                                                            │ │                                                                                                                                                    │ │    ### ReadManyFiles Result (Target Dir: `/Users/asdf/work/cat`)                                                                                   │ │                                                                                                                                                    │ │    Successfully read and concatenated content from **2 file(s)**.                                                                                  │ │                                                                                                                                                    │ │    **Processed Files:**                                                                                                                            │ │    - `References/UnrealEngine/Engine/Source/Runtime/Core/Public/Delegates/Delegate.h`                                                              │ │    - `References/UnrealEngine/Engine/Source/Runtime/Core/Public/Misc/CoreDelegates.h`                                                              │ ╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯✦ #if !UE_BUILD_DOCS        #include "Delegates/DelegateInstanceInterface.h"  #endif  분석이 완료되었습니다. 언리얼 엔진의 이벤트 시스템은 델리게이트(Delegates) 라는 강력한 개념을 기반으로 구축되어 있습니다. 이는 이전의 두 엔진(Hazel,  CryEngine)과는 다른 접근 방식입니다.  핵심 개념: 델리게이트 (Delegates)  언리얼 엔진의 이벤트 시스템의 핵심은 C++의 함수 포인터를 매우 안전하고 유연하게 확장한 델리게이트입니다. 델리게이트는 특정 함수 시그니처(반환 타입과  파라미터)를 가진 "대리자"이며, 여기에 하나 이상의 함수를 바인딩(binding)하여 필요할 때 실행시킬 수 있습니다.  Delegate.h 파일의 주석에 따르면, 이 시스템은 임의의 C++ 객체의 멤버 함수를 타입에 안전한(type-safe) 방식으로 호출할 수 있게 해줍니다.  주요 특징 및 구성 요소   1. 선언 (Declaration):       * 다양한 DECLARE_... 매크로를 사용하여 델리게이트 타입을 선언합니다. 이 매크로들은 함수 시그니처(파라미터 개수, 반환 값 유무 등)에 따라 여러 버전이         존재합니다.       * `DECLARE_DELEGATE`: 단일 함수만 바인딩할 수 있는 싱글캐스트(Single-cast) 델리게이트를 선언합니다.       * `DECLARE_MULTICAST_DELEGATE`: 여러 함수를 바인딩하고 한 번에 모두 실행할 수 있는 멀티캐스트(Multi-cast) 델리게이트를 선언합니다.       * `DECLARE_EVENT`: 멀티캐스트 델리게이트와 유사하지만, 선언된 클래스 내에서만 Broadcast를 호출할 수 있도록 접근을 제한하는 특별한 형태의         델리게이트입니다.       * `DECLARE_DYNAMIC_DELEGATE`: UObject 시스템과 통합되어 리플렉션(reflection)을 지원하는 델리게이트입니다. 블루프린트에서 사용하거나, 디스크에         저장(serialize)할 수 있습니다.   2. 바인딩 (Binding):       * 생성된 델리게이트 인스턴스에 실제 함수를 연결하는 과정입니다.       * 바인딩하는 대상 객체의 종류에 따라 다양한 Bind...() 함수를 제공하여 메모리 안전성을 높입니다.           * BindStatic(): 전역(global) 또는 정적(static) 함수를 바인딩합니다.           * BindRaw(): 일반 C++ 객체의 멤버 함수를 바인딩합니다. (객체의 소멸을 직접 관리해야 하므로 주의 필요)           * BindSP(), BindThreadSafeSP(): 스마트 포인터(TSharedPtr, TSharedRef)로 관리되는 객체의 멤버 함수를 바인딩합니다. 객체가 소멸되면 자동으로 바인딩이             해제됩니다.           * BindUObject(): UObject 파생 객체의 멤버 함수를 바인딩합니다. 약한 참조(weak reference)로 객체를 관리하여 안전합니다.           * BindLambda(): C++ 람다 함수를 바인딩합니다.       * 멀티캐스트 델리게이트의 경우 Add...(), Remove...() 등의 함수를 사용하여 함수 목록을 관리합니다.   3. 실행 (Execution):       * `Execute()`: 바인딩된 함수를 실행합니다. 델리게이트가 바인딩되지 않은 상태에서 호출하면 에러가 발생합니다.       * `ExecuteIfBound()`: 델리게이트가 바인딩된 경우에만 함수를 안전하게 실행합니다.       * 멀티캐스트 델리게이트의 경우 `Broadcast()` 함수를 사용하여 바인딩된 모든 함수를 순차적으로 실행합니다.   4. `CoreDelegates.h`:       * 엔진의 핵심적인 부분들(모듈 로딩, 렌더링 프레임 시작/종료, 패키지 로드, 입출력 등)에서 발생하는 주요 이벤트를 전역적인 델리게이트로 미리 정의해 둔         헤더 파일입니다.       * 예를 들어 FCoreDelegates::OnBeginFrame, FCoreDelegates::OnPostEngineInit 등이 있으며, 엔진의 다른 부분이나 게임 모듈에서 이 델리게이트에 함수를         바인딩하여 특정 시점에 원하는 로직을 수행할 수 있습니다. 이는 플러그인 아키텍처의 핵심이 되며, 모듈 간의 의존성을 낮추는 데 크게 기여합니다.  아키텍처 요약  언리얼 엔진의 이벤트 시스템은 콜백(Callback)을 일반화하고 강력하게 만든 델리게이트 시스템에 전적으로 의존합니다. 이는 특정 이벤트 타입을 열거하고  디스패처를 통해 분배하는 방식(Hazel, CryEngine의 시스템 이벤트)과는 근본적으로 다릅니다.   * 탈중앙화 및 유연성: 중앙 이벤트 관리자 없이, 필요한 곳 어디에서나 델리게이트를 선언하고 사용하여 객체 간의 통신 채널을 만들 수 있습니다.   * 메모리 안전성: 스마트 포인터 및 UObject 시스템과의 연동을 통해, 소멸된 객체의 함수를 호출하려는 시도를 대부분 안전하게 방지합니다.   * 강력한 통합: C++ 코드뿐만 아니라 블루프린트 비주얼 스크립팅과도 완벽하게 통합되어, 디자이너와 프로그래머가 동일한 이벤트 시스템 위에서 작업할 수     있습니다.  결론적으로, 언리얼 엔진은 타입에 안전하고, 메모리적으로 안전하며, 확장성이 매우 뛰어난 델리게이트 기반의 이벤트 시스템을 통해 엔진의 각 부분이 유기적으로  상호작용할 수 있는 강력한 기반을 제공합니다.